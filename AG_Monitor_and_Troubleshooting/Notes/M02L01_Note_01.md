### ✅ **What is `sp_server_diagnostics`?**
`sp_server_diagnostics` is a **system stored procedure** introduced in **SQL Server 2012** that collects **diagnostic and health information** about the SQL Server instance. Its primary purpose is to **detect potential failures** and provide a quick assessment of the server’s health. It is also used by **Windows Server Failover Clustering (WSFC)** to determine the health of SQL Server for automatic failover decisions.

---

### ✅ **Key Features**
- **Captures health data** for five main components:
  1. **system** – CPU usage, spinlocks, non-yielding tasks, page faults.
  2. **resource** – Memory usage, buffer pools, cache.
  3. **query_processing** – Worker threads, tasks, waits, blocking sessions.
  4. **io_subsystem** – I/O timeouts, pending I/O requests.
  5. **events** – Event information during execution.
- Returns a **state** for each component:
  - `0` = Unknown
  - `1` = Clean
  - `2` = Warning
  - `3` = Error
- Can be run from a **regular connection** or a **Dedicated Admin Connection (DAC)**.
- Used internally by **Always On Availability Groups** and **Failover Clustering** for health checks.

---

### ✅ **How to Use It**
- **Basic execution** (runs once and returns data):
  ```sql
  EXEC sp_server_diagnostics;
  ```
- **Repeat mode** (runs continuously at intervals until canceled):
  ```sql
  EXEC sp_server_diagnostics 10;  -- every 10 seconds
  ```
  - The parameter is `@repeat_interval` in seconds.
- **Output** includes:
  - `create_time` (timestamp)
  - `component_name` (system, resource, etc.)
  - `state` and `state_desc` (health status)
  - `data` (detailed info, often in XML)

---

### ✅ **Practical Use Cases**
- **Troubleshooting performance issues** (e.g., memory pressure, I/O bottlenecks).
- **Cluster health monitoring** for automatic failover.
- **Proactive monitoring** by capturing periodic snapshots of server health.
- Can be combined with **Extended Events** or inserted into a table for historical analysis.

---

#### ⚠️ **Important Notes**
- It’s **read-only** and safe to run in production.
- If you see it running continuously, that’s normal in clustered environments—it’s part of the health check mechanism.
- For Always On setups, it’s critical for **automatic failover decisions**.
